# 포인터에 대한 오해와 진실
### 임베디드 환경에서는 메모리에 접근 하려면 포인터가 반드시 필요 하지 않다.
임베디드 환경에서 개발자가 메모리 레이아웃을 설정하고 개발 하므로 포인터에 변수의 주소 뿐만
아니라 실제 주소값으로 초기화 가능하다. 이처럼 하려면 메모리 레이아웃을 잘 이해 해야된다.
메모리 직접 접근 방법을 사용하면 포인터 없이 메모리에 접근 하므로 오히려 속도를 높일 수 있다.

### 포인터와 포인터 연산은 +,- 외 여러 연산을 할 수 있다.
포인터는 다음과 같은 사칙 연산이 가능하다. 포인터와 정수는 +와 -가 가능하고 포인터 끼리 연산은 -만 가능하다.
다음 코드를 보자.
```C
  int *p, *q;
  q=104;
  q=100;

```
위의 소스에서  `p+q;`를 수행한다면 포인터끼리의 합은 메모리의 어느 위치를 나타낼지, 무엇이 들어 있는 위치를
나타낼지 모르기 때문에 위험하다. 그래서 컴파일 단에서 막고 있다. 하지만 - 연산은 두 포인터 사이에 얼마의 단위가
존재 하는지 검사하고 남은 메모리를 검사하는데 유용하다.

  정수와의 +,-  |    단항연산      | 포-포         | 대입          |          비교 |
   ------------ |    ------------- | ------------- | ------------- | ------------- |
   p+1;`,`p-1;  |     p++;`,`p--   | p - q;        | p = q;        | if(p>q){  }   |

`마지막의 if(p>q){  }`는 `unsigned int`간의 비교와 동일 하기 때문에 `if(104>100){  }`와 동일 하며 이 표현은 참이다.

###배열의 이름은 포인터가 아니다.
포인터의 특성은 값이 바뀔 수 있어야 하는데, 배열 이름은 `상수`이기 때문에 값이 바뀌지 않는다. 마찬가지로 &i도 주소를 나타내기는
하지만 포인터는 아니다. 배열 이름과 &i는 주소를 저장하거나 변경할 수 없기 때문이다.

###a[]배열과 &a는 같은 의미가 아니다.
```C
  a[3] = {1,2,3};
```
위와 같이 선언 하고 배열은 메모리 100번지에 저장이 되었다 가정하고 아래의 표는 배열의 주소와 값의 표현을 정리한 것이다.

실주소       | 값의 표현
------------ | -------------
0x100        | a[0] == *a
0x104        | a[1] == *(a+1)
0x108        | a[1] == *(a+2)

a = 0x100    | &a = 0x100
------------ | -------------
a+1 = 0x100  | &a+1 = 0x10c
  
`a는 배열의 첫 요소에 대한 주소를 나타낸다. 한 단위는 배열 한 칸을 의미하지만 &a는 배열의 시작 주소를 나타내므로, 한 단위는
배열 전체가 된다.`

```C
#include <stdio.h>
void main(void)
{
  int a[4] = {1,2,3,4};
  int i;
  for(i = 0; i < 4; i++)
  printf("주소 =%x a[%d]=%d\n", (a+1), i, *(a+1));
  printf("a\%x    &a=%x\n", a, &a);
  printf("a+1=%x  &a+1=%x\n", a+1, &a+1);
}

```
